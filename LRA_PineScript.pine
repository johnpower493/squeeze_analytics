// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0
// © 2026 Locked Range Analysis

//@version=6
indicator("Locked Range Analysis (LRA)", overlay=true, max_lines_count=500, max_labels_count=500)

// ═════════════════════════════════════════════════════════════════════════════
// INPUT PARAMETERS
// ═════════════════════════════════════════════════════════════════════════════

// Range Detection Settings
swingLength = input.int(3, "Swing High/Low Length", minval=1, maxval=20, group="Range Detection")
rangeMinBars = input.int(5, "Minimum Bars in Range", minval=3, maxval=50, group="Range Detection")
atrMult = input.float(1.5, "ATR Multiple for Range Height", minval=0.5, maxval=5.0, step=0.1, group="Range Detection")
rangeMaxBars = input.int(100, "Maximum Bars in Range", minval=20, maxval=200, group="Range Detection")
breakoutThreshold = input.float(0.5, "Breakout Threshold %", minval=0.1, maxval=2.0, step=0.1, group="Range Detection")

// TPSL Level Settings
tpsl1Method = input.string("Auto", "TPSL 1 Method", options=["Auto", "Range+Height", "Swing"], group="TPSL Levels")
useTPSL2 = input.bool(true, "Show TPSL 2 Levels", group="TPSL Levels")

// Visual Settings
showLR = input.bool(true, "Show Locked Ranges", group="Visual")
showTPSL1 = input.bool(true, "Show TPSL 1 Levels", group="Visual")
showTPSL2 = input.bool(true, "Show TPSL 2 Levels", group="Visual")
showImbalance = input.bool(true, "Show Imbalance Arrows", group="Visual")

// Color Settings
colorBuy = input.color(color.new(color.green, 0), "Buy/Bullish Color", group="Colors")
colorSell = input.color(color.new(color.red, 0), "Sell/Bearish Color", group="Colors")
colorNeutral = input.color(color.new(color.gray, 0), "Neutral Color", group="Colors")

// ═════════════════════════════════════════════════════════════════════════════
// HELPER FUNCTIONS
// ═════════════════════════════════════════════════════════════════════════════

// ATR for volatility measurement
atrVal = ta.atr(14)

// Pivot High/Low detection
pivotHigh = ta.pivothigh(high, swingLength, swingLength)
pivotLow = ta.pivotlow(low, swingLength, swingLength)

// Store swing highs and lows
var float[] swingHighs = array.new_float(100)
var float[] swingLows = array.new_float(100)
var int[] swingHighBars = array.new_int(100)
var int[] swingLowBars = array.new_int(100)

// Update swing arrays
if not na(pivotHigh)
    array.unshift(swingHighs, pivotHigh)
    array.unshift(swingHighBars, bar_index - swingLength)
    if array.size(swingHighs) > 50
        array.pop(swingHighs)
        array.pop(swingHighBars)

if not na(pivotLow)
    array.unshift(swingLows, pivotLow)
    array.unshift(swingLowBars, bar_index - swingLength)
    if array.size(swingLows) > 50
        array.pop(swingLows)
        array.pop(swingLowBars)

// ═════════════════════════════════════════════════════════════════════════════
// LOCKED RANGE DETECTION - IMPROVED
// ═════════════════════════════════════════════════════════════════════════════

// Range structure
var float lrHigh = na
var float lrLow = na
var int lrStartBar = na
var int lrEndBar = na
var bool lrActive = false
var string lrType = "Neutral"  // Resistance, Support, Gravitation
var float lrImbalance = 0.0  // Positive = Buy prevails, Negative = Sell prevails

// Visual elements
var box lrBox = na
var line[] tpsl1Lines = array.new_line()
var line[] tpsl2Lines = array.new_line()
var label lrLabel = na

// Volume analysis
volSMA = ta.sma(volume, 20)
volRatio = volume / volSMA

// Detect range consolidation - More sensitive approach
priceRange = high - low
avgRange = ta.sma(priceRange, 20)
isNarrowRange = priceRange < avgRange * atrMult

// Range detection variables
var int rangeBarCount = 0
var float sumHighInRange = 0.0
var float sumLowInRange = 0.0
var int highTouches = 0
var int lowTouches = 0
var float currentRangeTop = na
var float currentRangeBottom = na
var int currentRangeStart = na

// Flag to trigger cleanup
var bool clearVisuals = false

// Improved range detection logic
if not lrActive
    // Start new range detection
    if isNarrowRange
        if na(currentRangeTop)
            currentRangeTop := high
            currentRangeBottom := low
            currentRangeStart := bar_index
            rangeBarCount := 1
            highTouches := 0
            lowTouches := 0
            sumHighInRange := 0.0
            sumLowInRange := 0.0
        else
            // Expand range
            currentRangeTop := math.max(currentRangeTop, high)
            currentRangeBottom := math.min(currentRangeBottom, low)
            rangeBarCount := rangeBarCount + 1
            
            // Count touches - more sensitive threshold
            touchThreshold = atrVal * 0.15
            if high >= currentRangeTop - touchThreshold
                highTouches := highTouches + 1
                sumHighInRange := sumHighInRange + volume
            if low <= currentRangeBottom + touchThreshold
                lowTouches := lowTouches + 1
                sumLowInRange := sumLowInRange + volume
        
        // Check if range is valid - more flexible conditions
        if rangeBarCount >= rangeMinBars and (highTouches > 0 or lowTouches > 0)
            // Determine range type based on volume imbalance
            buyPressure = sumHighInRange / math.max(highTouches, 1)
            sellPressure = sumLowInRange / math.max(lowTouches, 1)
            
            maxPressure = math.max(buyPressure, sellPressure)
            lrImbalance := maxPressure > 0 ? (buyPressure - sellPressure) / maxPressure : 0.0
            
            // More sensitive range type determination
            if lrImbalance > 0.10
                lrType := "Resistance"  // Buy positions prevail
            else if lrImbalance < -0.10
                lrType := "Support"  // Sell positions prevail
            else
                lrType := "Gravitation"  // No significant imbalance
            
            // Activate range
            lrActive := true
            lrHigh := currentRangeTop
            lrLow := currentRangeBottom
            lrStartBar := currentRangeStart
            lrEndBar := bar_index
            
            // Reset range detection
            currentRangeTop := na
            currentRangeBottom := na
            currentRangeStart := na
            rangeBarCount := 0
            sumHighInRange := 0.0
            sumLowInRange := 0.0
            highTouches := 0
            lowTouches := 0
    else
        // Reset if range is broken or not narrow
        if not isNarrowRange
            currentRangeTop := na
            currentRangeBottom := na
            currentRangeStart := na
            rangeBarCount := 0
            sumHighInRange := 0.0
            sumLowInRange := 0.0
            highTouches := 0
            lowTouches := 0
    
    // Reset if range has gone on too long
    if not na(currentRangeStart) and (bar_index - currentRangeStart) > rangeMaxBars
        currentRangeTop := na
        currentRangeBottom := na
        currentRangeStart := na
        rangeBarCount := 0
        sumHighInRange := 0.0
        sumLowInRange := 0.0
        highTouches := 0
        lowTouches := 0

// Check for range breakout - need significant move outside range
rangeHeightPct = (lrHigh - lrLow) / lrLow * 100
breakoutAmount = rangeHeightPct * breakoutThreshold / 100
breakUpConfirm = lrActive and close > lrHigh * (1 + breakoutAmount) and high > lrHigh
breakDownConfirm = lrActive and close < lrLow * (1 - breakoutAmount) and low < lrLow

// Only trigger breakout if confirmed
bool breakUp = breakUpConfirm
bool breakDown = breakDownConfirm

// Set clearVisuals flag on breakout
if breakUp or breakDown
    clearVisuals := true
else
    clearVisuals := false

// ═════════════════════════════════════════════════════════════════════════════
// TPSL LEVELS CALCULATION
// ═════════════════════════════════════════════════════════════════════════════

// Get previous swing levels
var float prevSwingHigh = na
var float prevSwingLow = na
var int prevSwingHighBar = na
var int prevSwingLowBar = na

if lrActive
    // Find previous swings before range start
    for i = 0 to array.size(swingHighs) - 1
        if array.get(swingHighBars, i) < lrStartBar
            prevSwingHigh := array.get(swingHighs, i)
            prevSwingHighBar := array.get(swingHighBars, i)
            break
    
    for i = 0 to array.size(swingLows) - 1
        if array.get(swingLowBars, i) < lrStartBar
            prevSwingLow := array.get(swingLows, i)
            prevSwingLowBar := array.get(swingLowBars, i)
            break

// TPSL 1 Levels
float tpsl1High = na
float tpsl1Low = na

if lrActive
    rangeHeight = lrHigh - lrLow
    
    if tpsl1Method == "Range+Height"
        tpsl1High := lrHigh + rangeHeight
        tpsl1Low := lrLow - rangeHeight
    else if tpsl1Method == "Swing"
        tpsl1High := not na(prevSwingHigh) ? prevSwingHigh : lrHigh + rangeHeight
        tpsl1Low := not na(prevSwingLow) ? prevSwingLow : lrLow - rangeHeight
    else  // Auto
        tpsl1High := not na(prevSwingHigh) and prevSwingHigh > lrHigh ? prevSwingHigh : lrHigh + rangeHeight
        tpsl1Low := not na(prevSwingLow) and prevSwingLow < lrLow ? prevSwingLow : lrLow - rangeHeight

// TPSL 2 Levels (Behind previous swing)
float tpsl2High = na
float tpsl2Low = na

if lrActive and useTPSL2
    // Find swings behind the nearest previous swing
    foundFirstHigh = false
    for i = 0 to array.size(swingHighs) - 1
        if not foundFirstHigh and array.get(swingHighBars, i) < prevSwingHighBar
            foundFirstHigh := true
        else if foundFirstHigh and array.get(swingHighBars, i) < prevSwingHighBar
            tpsl2High := array.get(swingHighs, i)
            break
    
    foundFirstLow = false
    for i = 0 to array.size(swingLows) - 1
        if not foundFirstLow and array.get(swingLowBars, i) < prevSwingLowBar
            foundFirstLow := true
        else if foundFirstLow and array.get(swingLowBars, i) < prevSwingLowBar
            tpsl2Low := array.get(swingLows, i)
            break

// ═════════════════════════════════════════════════════════════════════════════
// PLOTTING & CLEANUP
// ═════════════════════════════════════════════════════════════════════════════

// Clear visual elements on breakout
if clearVisuals
    if not na(lrBox)
        box.delete(lrBox)
        lrBox := na
    // Clear TPSL 1 lines
    if array.size(tpsl1Lines) > 0
        line[] tempLines1 = array.copy(tpsl1Lines)
        array.clear(tpsl1Lines)
        for i = 0 to array.size(tempLines1) - 1
            line.delete(array.get(tempLines1, i))
        array.clear(tempLines1)
    // Clear TPSL 2 lines
    if array.size(tpsl2Lines) > 0
        line[] tempLines2 = array.copy(tpsl2Lines)
        array.clear(tpsl2Lines)
        for i = 0 to array.size(tempLines2) - 1
            line.delete(array.get(tempLines2, i))
        array.clear(tempLines2)
    // Clear label
    if not na(lrLabel)
        label.delete(lrLabel)
        lrLabel := na
    
    // Reset range state
    lrActive := false
    lrHigh := na
    lrLow := na
    lrStartBar := na
    lrEndBar := na
    lrType := "Neutral"
    lrImbalance := 0.0

// Range colors
color lrColor = lrType == "Resistance" ? colorBuy : lrType == "Support" ? colorSell : colorNeutral

// Draw Locked Range
if lrActive and showLR
    // Update or create range box
    if na(lrBox)
        lrBox := box.new(lrStartBar, lrHigh, bar_index, lrLow, bgcolor=color.new(lrColor, 90), border_color=lrColor, border_width=2)
    else
        box.set_left(lrBox, lrStartBar)
        box.set_top(lrBox, lrHigh)
        box.set_right(lrBox, bar_index)
        box.set_bottom(lrBox, lrLow)
        box.set_bgcolor(lrBox, color.new(lrColor, 90))
        box.set_border_color(lrBox, lrColor)
    
    // Range label (only create once)
    if na(lrLabel)
        lrLabelText = lrType + "\n" + str.tostring(lrImbalance * 100, "#.#") + "%"
        lrLabel := label.new(lrStartBar, lrHigh, lrLabelText, color=color.new(lrColor, 0), textcolor=color.white, style=label.style_label_down, size=size.small)

// Draw TPSL 1 Lines
if lrActive and showTPSL1 and not na(tpsl1High)
    if array.size(tpsl1Lines) < 2
        array.push(tpsl1Lines, line.new(lrEndBar, tpsl1High, bar_index, tpsl1High, color=color.new(colorBuy, 30), width=1, style=line.style_dashed))
        array.push(tpsl1Lines, line.new(lrEndBar, tpsl1Low, bar_index, tpsl1Low, color=color.new(colorSell, 30), width=1, style=line.style_dashed))
    else
        line.set_x1(array.get(tpsl1Lines, 0), lrEndBar)
        line.set_y1(array.get(tpsl1Lines, 0), tpsl1High)
        line.set_x2(array.get(tpsl1Lines, 0), bar_index)
        line.set_y2(array.get(tpsl1Lines, 0), tpsl1High)
        
        line.set_x1(array.get(tpsl1Lines, 1), lrEndBar)
        line.set_y1(array.get(tpsl1Lines, 1), tpsl1Low)
        line.set_x2(array.get(tpsl1Lines, 1), bar_index)
        line.set_y2(array.get(tpsl1Lines, 1), tpsl1Low)

// Draw TPSL 2 Lines
if lrActive and showTPSL2 and not na(tpsl2High)
    if array.size(tpsl2Lines) < 2
        array.push(tpsl2Lines, line.new(lrEndBar, tpsl2High, bar_index, tpsl2High, color=color.new(colorBuy, 50), width=1, style=line.style_dotted))
        array.push(tpsl2Lines, line.new(lrEndBar, tpsl2Low, bar_index, tpsl2Low, color=color.new(colorSell, 50), width=1, style=line.style_dotted))
    else
        line.set_x1(array.get(tpsl2Lines, 0), lrEndBar)
        line.set_y1(array.get(tpsl2Lines, 0), tpsl2High)
        line.set_x2(array.get(tpsl2Lines, 0), bar_index)
        line.set_y2(array.get(tpsl2Lines, 0), tpsl2High)
        
        line.set_x1(array.get(tpsl2Lines, 1), lrEndBar)
        line.set_y1(array.get(tpsl2Lines, 1), tpsl2Low)
        line.set_x2(array.get(tpsl2Lines, 1), bar_index)
        line.set_y2(array.get(tpsl2Lines, 1), tpsl2Low)

// Draw imbalance arrows
if lrActive and showImbalance and barstate.islast
    if lrType == "Resistance" and lrImbalance > 0.15
        label.new(bar_index, lrHigh + (lrHigh - lrLow) * 0.3, "▼", color=color.new(colorSell, 0), textcolor=color.white, style=label.style_label_down, size=size.large)
    else if lrType == "Support" and lrImbalance < -0.15
        label.new(bar_index, lrLow - (lrHigh - lrLow) * 0.3, "▲", color=color.new(colorBuy, 0), textcolor=color.white, style=label.style_label_up, size=size.large)

// Draw breakout labels
if breakUp
    label.new(bar_index, high, "▲ UP", color=color.new(colorBuy, 0), textcolor=color.white, style=label.style_label_up, size=size.normal)

if breakDown
    label.new(bar_index, low, "▼ DOWN", color=color.new(colorSell, 0), textcolor=color.white, style=label.style_label_down, size=size.normal)

// ═════════════════════════════════════════════════════════════════════════════
// INFORMATION TABLE
// ═════════════════════════════════════════════════════════════════════════════

var table infoTable = table.new(position.top_right, 2, 7, bgcolor=color.new(color.black, 80), border_width=1)

if barstate.islast
    table.cell(infoTable, 0, 0, "LRA Analysis", text_color=color.white, text_size=size.small)
    table.merge_cells(infoTable, 0, 0, 1, 0)
    
    table.cell(infoTable, 0, 1, "Range Type", text_color=color.gray, text_size=size.tiny)
    table.cell(infoTable, 1, 1, lrActive ? lrType : "None", text_color=lrActive ? lrColor : color.white, text_size=size.tiny)
    
    table.cell(infoTable, 0, 2, "Range High", text_color=color.gray, text_size=size.tiny)
    table.cell(infoTable, 1, 2, lrActive ? str.tostring(lrHigh, "#.####") : "N/A", text_color=color.white, text_size=size.tiny)
    
    table.cell(infoTable, 0, 3, "Range Low", text_color=color.gray, text_size=size.tiny)
    table.cell(infoTable, 1, 3, lrActive ? str.tostring(lrLow, "#.####") : "N/A", text_color=color.white, text_size=size.tiny)
    
    table.cell(infoTable, 0, 4, "Imbalance", text_color=color.gray, text_size=size.tiny)
    table.cell(infoTable, 1, 4, lrActive ? str.tostring(lrImbalance * 100, "#.#") + "%" : "N/A", text_color=lrActive ? lrColor : color.white, text_size=size.tiny)
    
    table.cell(infoTable, 0, 5, "TPSL 1 High", text_color=color.gray, text_size=size.tiny)
    table.cell(infoTable, 1, 5, lrActive and not na(tpsl1High) ? str.tostring(tpsl1High, "#.####") : "N/A", text_color=color.white, text_size=size.tiny)
    
    table.cell(infoTable, 0, 6, "TPSL 1 Low", text_color=color.gray, text_size=size.tiny)
    table.cell(infoTable, 1, 6, lrActive and not na(tpsl1Low) ? str.tostring(tpsl1Low, "#.####") : "N/A", text_color=color.white, text_size=size.tiny)

// ═════════════════════════════════════════════════════════════════════════════
// ALERTS
// ═════════════════════════════════════════════════════════════════════════════

alertcondition(lrActive and lrType == "Resistance", title="Resistance LR Detected", message="Resistance Locked Range detected")
alertcondition(lrActive and lrType == "Support", title="Support LR Detected", message="Support Locked Range detected")
alertcondition(lrActive and lrType == "Gravitation", title="Gravitation LR Detected", message="Gravitation Locked Range detected")
alertcondition(breakUp, title="Breakout Up", message="Price broke out above LR")
alertcondition(breakDown, title="Breakout Down", message="Price broke out below LR")
